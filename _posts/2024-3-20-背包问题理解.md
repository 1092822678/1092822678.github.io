---
layout: post
title: "背包问题理解 - 由0-1背包到完全背包"
date:   2024-3-20
tags: [算法]
comments: true
author: zlchen
---

<!-- more -->
- [由0-1背包到完全背包的分析](#由0-1背包到完全背包的分析)
  - [二维数组dp](#二维数组dp)
	- [问题分析](#问题分析)
  - [一维滚动数组](#一维滚动数组)
  - [一维滚动数组如何理解](#这个公式如何理解呢？)

- [背包问题遍历顺序](#背包问题遍历顺序)


# 由0-1背包到完全背包的分析
## 二维数组dp
### 问题分析
1. dp数组含义  
$dp[i][j]$ 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少   
result 就是 max{dp[i][0~V]}

2. 递推公式：  
$dp[i][j]: $
    - 不选择第i个物品: $dp[i][j] = dp[i-1][j]$
    - 选择第i个物品: $dp[i][j] = dp[i-1][j-weight[i]] + value[i]$

递推公式: $dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])$

3. dp数组初始化  
    - 如果物品从0开始编号，那么初始化  
    $
    dp[0][j] = 
    \begin{cases}
    0, j<weight[0] \\
    value[0], j>=weight[0]
    \end{cases}
    $  
    遍历物品时候从1开始遍历  
    - 如果物品从1开始编号，那么直接将dp数组初始化为0即可  
    同样从遍历物品时从1开始遍历

4. 确定遍历顺序  
由于是二维，所以需要确定先遍历背包OR先遍历物品，还要确定顺序遍历还是倒叙遍历  
根据递推公式可以知道，`dp[i][j]`的状态只和左上角的有关系，所以可以根据数组模拟一遍，无论是先遍历i还是先遍历j都可以  
![模拟背包](https://1092822678.github.io/images/dp.png)

## 一维滚动数组
根据二维dp的递推公式$dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])$, 我们可以看出来, dp[i]的状态只和dp[i-1]有关, 也就是说, dp[0]到dp[i-2]的状态我们都不需要保留，所以进行递推的时候，我通过dp[0]得到了dp[1]之后，直接将dp[0]覆盖掉，因为这已经是不需要利用的了，以此类推，整个第一维就被压缩了，因此，我们可以得到以下的一维滚动递推公式  
$$dp[j] = max(dp[j], dp[j-weight[i]] + value[i])$$  

## 这个公式如何理解呢？  

> 一维dp数组，其实就是上一层 dp[i-1] `拷贝`到 dp[i]来  
> 如果把dp[i - 1]那一层拷贝到dp[i]上，二维的dp表达式完全可以是：  
$dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])$  

按`拷贝`来理解，可以将状态拆分为两步，首先dp[i]拷贝了dp[i-1]的值，那么，为了保留dp[i-1]`左上`的状态，我们就必须从`从后往前`对j进行遍历, 因为计算dp[i][j]的时候，从后往前遍历，dp[i][0]到dp[i][j-1]的状态依然是dp[i-1][0]到dp[i-1][j-1]的拷贝，还没有覆盖，也就还是由`左上角`确定

而如果顺序去遍历，dp[i][j]就会由`左和左上`的状态来决定了，那左边的状态是什么呢，左边的状态已经包含了这个物品选或者不选，也就是说，顺序遍历背包的话，这个物品的取舍状态已经被包含了，所以顺序遍历，物品就可以遍历多次，也就转化为了完全背包问题。  



# 背包问题遍历顺序

就是看物品的顺序对结果有没有影响

> 先遍历背包在遍历物品 - 求`排列数` (口诀:宝物牌)

> 先遍历物品在遍历背包 - 求`组合数` (口诀:误报组)




